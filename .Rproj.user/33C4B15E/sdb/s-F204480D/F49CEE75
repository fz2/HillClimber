{
    "contents" : "---\ntitle: \"HillClimbing\"\n\n\nauthor: \"Fan Zhang'17\"\n\n\ndate: \"`r Sys.Date()`\"\noutput: rmarkdown::pdf_document\nvignette: >\n  %\\VignetteIndexEntry{Vignette Title}\n  %\\VignetteEngine{knitr::rmarkdown}\n  \\usepackage[utf8]{inputenc}\n---\n\nHillClimbing is a R package created to reproduce results in the paper “Local Hillclimbing on an Economic Landscape” by David Kane in 1996. \nThe package has a class named 'HillClimbing\"\" and six different methods: generateObject( ), profitFunction( ), findNeighborhood( ), neighborhoodProfit( ), climbingStrategy( ) and paperResult( ). \n\n## Paper background\nThe paper introduces an interesting idea of economic hillclimbing for different firms. Considering a firm faced with single-period profit maximization problem, the paper proposes a model with following basic components: \n\n1. The set of inputs:\n\n$x=x_1x_2 \\cdots x_n\\mbox with x_i\\in\\{0,1,2,\\cdots\\}$\n\n2. Budget constraint: \n\n$\\sum^n_{i=1}x_i = B\\in\\{0,1,2,\\cdots\\}$\n\n3. Profit function: \n\n$\\pi(X) = c_1x_1 + c_2x_2 + \\cdots + c_nx_n + c_{n+1}x_1^2 + c_{n+2}x_2^2 + \\cdots + c_{2n}x_n^2+ c_{2n+1}x_1x_2 +c_{2n+2}x_1x_3+\\cdots+ c_{n\\frac{n+3}{2}}x_{n-1}x_n$\n\nThe paper pictures profit functions as economic landscapes and introduces the idea of a neighborhood.The neighborhood of a given allocation X is the set of points such that all the individual allocations are identical except for two; and for those two, one input receives one more dollar and the other input receives one less. \n\n\nAfter calculating all possible outcomes of neighborhood allocations, the company has three choices regarding where to move the company: to choose the maximum in the neighborhood set and move the company to the corresponding budget allocation (SA),to choose the median in the neighborhood set higher than original profit (MA), or to choose the minimum in the neighborhood set higher than original level (LA).\n\n\nBy computing mean normalized profits for different firm strategies and different connections, the paper points out the superiority of the Least Ascent (LA) strategy. The paper suggests that it might be advisable for companies to be patient and choose the LA strategy to achieve their ultimate profit maximization. \n\n## Package\n### Definition of slots in HillClimbing class\n\n1. approach: three simple strategies for hillclimbing firms, users should put \"SA\", \"MA\" or \"LA\" in this slot\n2. budget: the amount of firm's total budget\n3. input: the number of total inputs\n4. connection: the number of connections per input\n5. allocation: a vector which contains a set of inputs subject to the budget constraint, a randomized allocation for the firm\n6. linearConstraint: a vector which gives upper and lower constraints for linear coefficients\n7. squareConstraint: a vector which gives upper and lower constraints for square coefficients\n8. crossproductConstraint: a vector which gives constraints for cross product coefficients\n9. coef1: a vector which stores all linear coefficients of the profit function\n10. coef2: a matrix which stores all quadratic coefficients (both square and cross product coefficients) of the profit function\n\n### Package usage\n\nWe first install and load the package. \n```{r eval=FALSE}\nlibrary(HillClimbing)\n```\nTo reproduce results in the paper, we need to give the package an object in the following format. We can change the value of different slots in the object. \n```{r eval=FALSE}\n  object <- new(\"HillClimbing\", approach=\"SA\", \n                    budget=50, input=20, connection=2, \n                    linearConstraint=c(-1,1),\n                    squareConstraint=c(-1,1),\n                    crossproductConstraint=c(-1,1)\n                    )\n\n```\nWe start by using the method generateObject( ) and we can get an object with all slots filled. \n```{r eval=FALSE}\nobject <- generateObject(object)\n```\nThen we calculate the profit of the starting allocation with method profitFunction( ).\n```{r eval=FALSE}\nprofitFunction(object)\n```\nWe can find the neighborhood (all neighbors) of the starting allocation with method findNeighborhood( ).\n```{r eval=FALSE}\nfindNeighborhood(object)\n```\nWe then get all neighborhood profits with method neighborhoodProfit( ). \n```{r eval=FALSE}\nneighborhoodProfit(object)\n```\nWe use the method climbingStrategy( ) to find the profit maximum in the local landscape.\n```{r eval=FALSE}\nclimbingStrategy(object)\n```\nFinally, to find our mean normalized profits over many landscapes, we run the method paperResult( ). We may change the number of times we use the climbing strategy (the number of landscapes) by changing t in the paperResult() function. \n```{r eval=FALSE}\npaperResult(object)\n```\n\nHowever, if we are not interested in these details and want a quick result, we can also run method paperResult( ) directly after giving the object. \n```{r eval=FALSE}\n  object <- new(\"HillClimbing\", approach=\"SA\", \n                    budget=50, input=20, connection=2, \n                    linearConstraint=c(-1,1),\n                    squareConstraint=c(-1,1),\n                    crossproductConstraint=c(-1,1)\n                    )\n  paperResult(object)\n```\n\n## Methods \nThis R package uses six different methods to reproduce results in the paper. Each method is explained separately below. \n\n### 1. generateObject( )\nThis method is used to generate all slots of the object. It gives the object a random starting allocation and randomizes coefficients of the profit function. \n\nWe generate a starting allocation subject to the budget constraint. We randomize the allocation of each dollar of the budget. \n```{r eval=FALSE}\nn <- object@input\nobject@allocation <- rep(0,n)\n    for (i in 1:object@budget){\n      random <- sample(1:n,1,replace=T)\n      object@allocation[random] <- object@allocation[random]+1 \n    }\n```\nWe put the randomized allocation into the slot \"allocation\". Then we randomize coefficients of the profit function and put these coefficients into slots \"coef1\" and \"coef2\". \n```{r eval=FALSE}\n    coef1 <- object@coef1\n    coef2 <- object@coef2\n    coef2 <- matrix(0,nrow=n,ncol=n)\n    # randomize linear coefficients\n    coef1 <- runif(n,object@linearConstraint[1], object@linearConstraint[2])\n    for(i in 1:n){\n      for (j in i:n){\n        # randomize square coefficients\n        if(i==j){\n          coef2[i,j] <- runif(1,object@squareConstraint[1],object@squareConstraint[2])\n        }\n        # randomize cross product coefficients\n        else {\n          coef2[i,j] <- runif(1,object@crossproductConstraint[1],\n                              object@crossproductConstraint[2])/2\n          coef2[j,i] <- runif(1,object@crossproductConstraint[1],\n                              object@crossproductConstraint[2])/2 \n          }\n      }\n    }\n   return(object)\n```\n\n### 2. profitFunction( )\nThis method is used to calculate the normalized profit level for the given allocation. We calculate the profit by adding linear terms and quadratic terms(square and cross product terms) of the profit function. We then normalize the profit value and return it as a vector. \n\n```{r eval=FALSE}\n    allocation <- object@allocation\n    coef1 <- object@coef1\n    coef2 <- object@coef2\n    profit <- coef1%*%allocation+allocation%*%(coef2%*%allocation)\n    profit.norm <- as.vector((100*profit/(object@budget+object@budget^2)))\n    return(profit.norm)\n```\n\n### 3. findNeighborhood( )\nThis method is used to find all neighbors of the given allocation in the economic landscape. We put all neighbors into columns of a matrix and return the neighborhood matrix. \n\nWe first define a n by n adjacency matrix to represent connection status between inputs (1 represents connected and 0 represents unconnected). In this way, if the number of connections is c, we can randomly connect an input wth c other inputs. \n\n```{r eval=FALSE}\n    n <- object@input\n    connections <- matrix(0,nrow=n,ncol=n)\n    for (i in 1:n){\n      c <- 0\n      while (c < object@connection){\n        j <- sample(1:n,1,replace=T)\n        while((i==j)|(connections[i,j]==1)){\n          j <- sample(1:n,1,replace=T)\n        }\n        connections[i,j]=1\n        c <- c+1  \n      }\n    } \n```\n\nWe start with the initial randomized allocation. If there exists a connection between Xi and Xj, we then transfer one dollar from input Xi to input Xj. Since we don't know the number of neighbors, we define 1000 columns at first and delete columns of zeros later. We return a neighborhood matrix with each neighbor in a separate column. \n```{r eval=FALSE}\n    neighbors <- matrix(0,nrow = n, ncol = 1000)\n    k <- 1\n    for (i in 1:n){\n      for (j in 1:n){\n        newNeighbor <- object@allocation\n        if (connections[i,j] == 1 && newNeighbor[i]>0){    \n          newNeighbor[i] <- newNeighbor[i]-1\n          newNeighbor[j] <- newNeighbor[j]+1\n          neighbors[, k] <- newNeighbor\n          k <- k + 1    \n        }\n      }\n    }\n    # find out columns of zeros\n    for(m in 1:1000){\n      if(sum(neighbors[, m]) == 0) {\n        break\n      }\n    }\n    neighbors <- neighbors[,1:(m-1)]\n    return(neighbors)\n```\n\n\n### 4. neighborhoodProfit( )\nThis method is used to calculate normalized profits for all neighbors found in the landscape. We use the same method to calculate the profit of each neighbor and store all normalized neighborhood profits in a vector.  \n```{r eval=FALSE}\n    neighbors <- findNeighborhood(object)\n    neighbors.iniprofit <- rep(0,ncol(neighbors))\n    for (k in 1:ncol(neighbors)){ \n      coef1 <- object@coef1\n      coef2 <- object@coef2\n      neighbors.iniprofit[k] <- (coef1)%*%neighbors[,k]+neighbors[,k]%*%(coef2%*%neighbors[,k])  \n      neighbors.profit <- 100*neighbors.iniprofit/(object@budget + object@budget^2)\n      }\n    return(neighbors.profit)\n```\n\n### 5. climbingStrategy( )\nThis method is used to calculate the normalized profit maximum on a local economic landscape. As the paper discusses, there are three strategies for hillclimbing firms: Steepest Ascent(SA), Median Ascent(MA) and Least Ascent(LA). This method returns the maximum profit of the local landscape. \n\n```{r eval=FALSE}\n    neighbors <- findNeighborhood(object)\n    profit.norm <- profitFunction(object)\n    select <- NULL\n    current.profit <- profit.norm\n    neighbors.profit <- neighborhoodProfit(object)\n    landscape.max <- 0\n    # loop ends when there is no neighborhood profit higher than the current profit level\n    while(length(neighbors.profit[which(neighbors.profit>profit.norm)])!=0) { \n      # select the subset of neighborhood profits higher than the current profit level \n      select <- neighbors.profit[which(neighbors.profit>profit.norm)]  \n      # the Steepest Ascent strategy\n      if(object@approach ==\"SA\"){\n        k <- which(neighbors.profit==max(select))\n        current.profit <- neighbors.profit[k]\n      }\n      # the Median Ascent strategy\n      else if(object@approach == \"MA\"){\n        medianIndex <- which.min(abs(select-median(select)))\n        k <- which(neighbors.profit==select[medianIndex])\n        current.profit <- neighbors.profit[k]\n      }\n      # the Least Ascent strategy    \n      else if(object@approach == \"LA\"){\n        k <- which(neighbors.profit == min(select)) \n        current.profit <- neighbors.profit[k]\n      }\n      # move from the starting allocation to its neighbor given different approaches\n      object@allocation <- neighbors[,k]  \n    }\n    landscape.max <- current.profit\n    return(landscape.max)\n```\n\n### 6. paperResult( )\nThis method is used to run the climbingStrategy( ) method for t times and find the mean normalized profit over t different landscapes. We may change the number of t as we hillclimb over different number of landscapes. \n\n```{r eval=FALSE}\n    # t is the number of times we want to use the according strategy\n    t <- 1000\n    Result <- NULL\n    for (i in 1:t){\n      Result[i] <- climbingStrategy(object)\n      result <- mean(Result)\n    }\n    return(result)\n```\n\n## Results and Conclusion\n### 1. Table 1\nMean normalized profits over 1000 landscapes for different firm strategies and connections per input. \n\nFor this table, budget=50, input=20, linearConstraint=c(-1,1), squareConstraint=c(-1,1), crossproductConstraint=c(-1,1).\n\n| Connections per input |     1     |  2   |  3   | 4   | 5   |\n|----------|:-------------:|:------:|:------:|:------:|:-----------:|:------:|\n| Steepest Ascent | 14.97216 | 25.36077\t| 30.16342 |\t38.22828\t| 43.48658  |\n| Median Ascent |   15.8626 |  24.77427\t| 31.27791 | \t36.38747  |\t44.07121  |\n| Least Ascent | 23.79984  | 29.4174 |\t35.43877\t| 39.96177\t| 46.17567 |\n\n\n### 2. Table 2\nMean normalized profits over 1, 000 landscapes for different firm strategies and connections per input. \n\nFor this table, budget=50, input=20, linearConstraint=c (0,1), squareConstraint=c (0,1), crossproductConstraint=c (-1,0). \n\n| Connections per input |     1     |  2   |  3   | 4   | 5   |\n|----------|:-------------:|:------:|:------:|:------:|:-----------:|:------:|\n| Steepest Ascent | -2.88448  | 7.247748\t| 11.08525\t| 16.66479\t| 20.28711  |\n| Median Ascent |  -2.89668 |  6.092761\t| 14.3331\t| 15.76148\t| 22.6064  |\n| Least Ascent |-2.81460 |  7.204734\t| 15.23751\t| 16.53196\t| 25.41239|\n\n### 3. Table 3\nMean normalized profits over 1, 000 landscapes for different firm strategies and connections per input. \n\nFor this table, budget=50, input=20, linearConstraint=c (0,0), squareConstraint=c (-19,0), crossproductConstraint=c (0,2). \n| Connections per input |     1     |  2   |  3   | 4   | 5   |\n|----------|:-------------:|:------:|:------:|:------:|:-----------:|:------:|\n| Steepest Ascent |-8.423737 | 0.266066\t| 10.24508\t| 12.9103\t| 21.98578 |\n| Median Ascent |  3.95997 |\t2.77561\t| 8.37276 |\t13.05479\t| 16.03198 |\n| Least Ascent | 7.89083  | 5.571232 |\t9.62705 | 10.464833 | 15.2346 |\n\n### 4. Conclusion\nThe results produced from the R package successfully test and support the idea in the paper. We notice that in the first two tables, Least Ascent strategy generally reaches higher profit levels than Median Ascent and Steepest Ascent. In the third table, LA has an advantage at first but loses to MA and SA as the number of connections increases to 4 and 5. This result is consistent with the paper. \n\n## References\nDavid Kane, “Local Hillclimbing on an Economic Landscape,” 1996\n\n",
    "created" : 1423164140341.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3627706313",
    "id" : "F49CEE75",
    "lastKnownWriteTime" : 1423166017,
    "path" : "~/Desktop/HillClimber/vignette/HillClimbing paper.Rmd",
    "project_path" : "vignette/HillClimbing paper.Rmd",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}